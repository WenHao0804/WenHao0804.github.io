<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Edit Distance</title>
    <link href="/2022/03/02/Levenshtein-edit-distance/"/>
    <url>/2022/03/02/Levenshtein-edit-distance/</url>
    
    <content type="html"><![CDATA[<h1 id="opening-question">Opening question</h1><p>我们来考虑这样一个问题：给定两个句子，判断这两个句子之间的相似度。直观来看，如果句子1和句子2之间只有几个字不同，其余字都一模一样，那这两个句子必然极为相似。换言之，如果句子1可以很容易地被修改成句子2，则说明这两个句子相似性很大。</p><blockquote><p>举例说明两个句子极为相似的情况：</p><p>s1 = "我是一只小小小小鸟，想要飞呀飞却飞也飞不高"</p><p>s2 = "我是一条小小小小狗，想要睡呀睡却睡也睡不够"</p></blockquote><p>这个思考问题中涉及到一个核心的问题：什么是相似度。直观来看，两个句子之间的相似度和将它们修改成对方的难易度有关。如果我们可以定量评价将句子1修改成句子2的“成本”，那不是很容易能判断句子之间的相似度了吗？这个“成本”有着规范的名字，也就是编辑距离（Edit Distance）。</p><h1 id="hamming距离">Hamming距离</h1><p>我们并不是最先思考编辑距离的人，早在1950年，一位如今大名鼎鼎的科学家汉明（Hamming）在对二元信道检错及纠错码的<a href="https://ieeexplore.ieee.org/ielx7/6731005/6772728/06772729.pdf?tag=1">研究</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Hamming R W . Error detecting and error correcting codes[J]. Bell Labs Technical Journal, 1950, 29(2):147-160.">[1]</span></a></sup>中提出了一种判断<span class="math inline">\(\{0, 1\}^n\)</span>空间内两个坐标距离的方法。这个空间内共有<span class="math inline">\(2^n\)</span>个点，任意一个维度中的坐标只能取0或1。对于此空间内的一个点，如果某个维度下的坐标出了错则该维度下的坐标会从0反转为1或从1反转为0。汉明基于此定义两个点<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>之间的距离<span class="math inline">\(D(x, y)\)</span>为n个维度中<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>坐标不同的数量，这也就是汉明距离。汉明距离有如下特点： <span class="math display">\[\begin{align}D(x,y) = 0 &amp;&amp; if\ and\ only\ if\ x == y \\D(x, y) = D(y, x) &gt; 0 &amp;&amp; if\ x \ne y \\D(x, y) + D(y, z) \ge D(x, z) &amp;&amp;triangle\ inequality\end{align}\]</span></p><p>我们来举例计算汉明距离：比如<span class="math inline">\(x=[0, 0, 0,1]\)</span>，<span class="math inline">\(y=[0, 0, 1, 0]\)</span>，<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>第3和第4个维度不同，那么它们之间的汉明距离就是2。</p><p>换一种视角，如果我们将<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>当作两个句子，我们就可以利用汉明距离去计算两个句子相互修改的难易“成本”，也就是编辑距离。但这种计算方法有其固有缺点：只能应对两个句子长度相同的情况。如果两个句子长度不同，那我们就无法利用汉明距离计算两个句子间的编辑距离了。</p><h1 id="levenshtein距离">Levenshtein距离</h1><p>那么如何计算两个长度不同的句子之间的编辑距离呢？基于汉明的工作，俄国科学家Levenshtein于1965年在其<a href="https://nymity.ch/sybilhunting/pdf/Levenshtein1966a.pdf">文章</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Levenshtein V I . Binary codes capable of correcting deletions, insertions and reversals[J]. Doklady Akademii Nauk SSSR, 1965, 163.">[2]</span></a></sup>《可纠正删除、插入、反转的二进制纠错码》中提出了一种新的判断两个点<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>距离<span class="math inline">\(D(x,y)\)</span>的方法。这种计算方法的物理意义是每次修改一个坐标将<span class="math inline">\(x\)</span>修改为<span class="math inline">\(y\)</span>的最次少数，支持的修改方式有增、删、改。Levenshtein提出的评价指标如今成为了有名的Levenshtein距离，已经被广泛应用在生物信息学（Bioinformatics）、自然语言处理<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Aziz R , Anwar M W , Jamal M H , et al. A hybrid model for spelling error detection and correction for Urdu language[J]. 2021.">[4]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Mei J , Islam A , Moh&#39; D A , et al. Statistical learning for OCR error correction[J]. Information Processing &amp; Management, 2018, 54(6):Pages 874–887.">[5]</span></a></sup>（Nature Language Processing，NLP）等多个研究领域中，用于评价两个序列之间的距离。</p><p>递归性地定义Levenshtein距离如下： <span class="math display">\[D_{x,y}(i, j)=\begin{cases}max(i,j)&amp;&amp;if\ min(i, j) == 0\\min\begin{cases}        D_{x,y}(i-1,j)+1\\        D_{x,y}(i,j-1)+1 \\        D_{x,y}(i-1,j-1)+1_{x_i\ne y_j}\\     \end{cases}&amp;&amp;  otherwise\end{cases}\]</span> <span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>表示两个序列（比如字符串），<span class="math inline">\(D_{x,y}(i,j)\)</span>表示<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符之间的Levenshtein距离，其中<span class="math inline">\(i\)</span>、<span class="math inline">\(j\)</span>从1开始计数。如果序列<span class="math inline">\(x\)</span>的长度为0，显然只需要插入<span class="math inline">\(j\)</span>个字符就可以将<span class="math inline">\(x\)</span>变成<span class="math inline">\(y\)</span>，同理对于<span class="math inline">\(y\)</span>的长度为0时也适用。当两个序列长度均不为0时，存在三种情况：</p><ol type="1"><li>删除<span class="math inline">\(x_[i]\)</span>，使<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符相同</li><li>删除<span class="math inline">\(y[j]\)</span>，使<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符相同</li><li><span class="math inline">\(x\)</span>的前<span class="math inline">\(i-1\)</span>个字符经过操作已经和<span class="math inline">\(y\)</span>的前<span class="math inline">\(j-1\)</span>个字符相同时，为使<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符相同：<ul><li>如果<span class="math inline">\(x[i]==y[j]\)</span>，则无需操作；</li><li>否则，将<span class="math inline">\(x[i]\)</span>修改成<span class="math inline">\(y[j]\)</span>或将将<span class="math inline">\(y[i]\)</span>修改成<span class="math inline">\(x[j]\)</span>即可</li></ul></li></ol><p>显然，计算Levenshtein距离要明显比计算汉明距离困难。不过一旦理清算法，用计算机实现轻而易举。</p><h2 id="levenshtein距离的编程实现">Levenshtein距离的编程实现</h2><h3 id="递归实现">递归实现</h3><p>上方我们已经得到了Levenshtein距离的递归定义式，接下来我们只需要将这个递归式放入编程语言中即可。为了提升效率，我们需要对递归结果进行缓存，要不然会产生太多重复计算，一旦句子太长等递归结果出来就要天荒地老了。不过递归加上缓存之后，也就不再是纯粹的递归了。利用python可以较简洁地递归计算Levenshtein距离，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-meta">@functools.lru_cache</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">levenshtein</span>(<span class="hljs-params">sentence1, sentence2, i=<span class="hljs-literal">None</span>, j=<span class="hljs-literal">None</span></span>):<br>    i = i <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(sentence1)<br>    j = j <span class="hljs-keyword">if</span> j <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(sentence2)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> i <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> j:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(i, j)<br>    cost = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> sentence1[i-<span class="hljs-number">1</span>] != sentence2[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<br>        levenshtein(sentence1, sentence2, i - <span class="hljs-number">1</span>, j) + <span class="hljs-number">1</span>,<br>        levenshtein(sentence1, sentence2, i, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>,<br>        levenshtein(sentence1, sentence2, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + cost,<br>    )<br></code></pre></td></tr></table></figure><h3 id="递推实现">递推实现</h3><p>递归转递推其实就是显式地用数组来表达递归调用栈，并从递归过程的最底层往上递推。代码如下，整体上和递归代码差别不大，无非是多了显式递推的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">levenshtein</span>(<span class="hljs-params">sentence1, sentence2</span>):<br>    n1, n2 = <span class="hljs-built_in">len</span>(sentence1), <span class="hljs-built_in">len</span>(sentence2)<br>    dp = [[<span class="hljs-number">0</span>] * (n2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1 + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n1 + <span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n2 + <span class="hljs-number">1</span>):<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n1 + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n2 + <span class="hljs-number">1</span>):<br>            cost = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> sentence1[i - <span class="hljs-number">1</span>] == sentence2[j - <span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(<br>                dp[i-<span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,<br>                dp[i][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,<br>                dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + cost,<br>            )<br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="lcs最长公共子序列">LCS：最长公共子序列</h1><p>Levenshtein距离允许的编辑操作为：删除、插入、替换。这样的编辑操作就是较为常用的编辑定义，因此我们在提到编辑距离时，通常指的就是Levenshtein距离。如果我们限定编辑操作仅指替换，那这样的编辑距离就是我们在上方提到的Hamming距离。</p><p>如果我们限定编辑操作为删除、插入呢？换句话来说：给定句子1和句子2，一次可对任一句子进行删除或插入的操作，最少操作多少步可使得句子1和句子2相同？</p><p>先不管这个问题的结果是什么。显然，经过操作后，两个句子剩下的部分在原始句子中依然存在，但可能每个字符的下标发生了变化。那么这个问题就可以被转化为，求两个句子的最长公共子序列（Longest Common Subsequence，LCS）问题。</p><p><img src="/img/lcs.png"/></p><p align="center" style="font-size: small;">图1 两个序列的最长公共子序列，如"AGGTAB"和"GXTXAYB"的最长公共子序列是"GTAB"</p><p>LCS问题是一个经典的计算机科学问题，也是如diff、git等具有数据比较功能程序的算法基础。在LCS问题中，子序列不需要在原序列中占用连续的位置。一般性的LCS问题是NP-hard问题。但当序列的长度确定时，LCS问题可以使用动态规划在多项式时间内解决<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="屈, 婉玲. 算法设计与分析. 北京清华大学学研大厦A座: 清华大学出版社. 2011: 67. ISBN 978-7-302-24756-2.">[6]</span></a></sup>。</p><h2 id="两个序列lcs的解法">两个序列LCS的解法</h2><h1 id="由编辑距离计算句子相似度">由编辑距离计算句子相似度</h1><blockquote><blockquote><blockquote><p>【TODO】待更新</p></blockquote></blockquote></blockquote><hr /><h1 id="references">References：</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Hamming R W . Error detecting and error correcting codes[J]. Bell Labs Technical Journal, 1950, 29(2):147-160. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Levenshtein V I . Binary codes capable of correcting deletions, insertions and reversals[J]. Doklady Akademii Nauk SSSR, 1965, 163. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Berger B , Waterman M S , Yu Y W . Levenshtein Distance, Sequence Comparison and Biological Database Search[J]. IEEE Transactions on Information Theory, 2020, PP(99):1-1. <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Aziz R , Anwar M W , Jamal M H , et al. A hybrid model for spelling error detection and correction for Urdu language[J]. 2021. <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Mei J , Islam A , Moh' D A , et al. Statistical learning for OCR error correction[J]. Information Processing &amp; Management, 2018, 54(6):Pages 874–887. <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>屈, 婉玲. 算法设计与分析. 北京清华大学学研大厦A座: 清华大学出版社. 2011: 67. ISBN 978-7-302-24756-2. <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About the blog</title>
    <link href="/2022/03/01/about-blog/"/>
    <url>/2022/03/01/about-blog/</url>
    
    <content type="html"><![CDATA[<p>本博客基于<a href="https://hexo.io">hexo</a>框架搭建，使用主题为<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>。</p><p>hexo的文档参考<a href="https://hexo.io/docs">链接</a>, fluid主题的配置文档参考<a href="https://hexo.fluid-dev.com/docs/guide/">链接</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/27/hello-world/"/>
    <url>/2022/02/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个测试文档</title>
    <link href="/2022/02/27/%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"/>
    <url>/2022/02/27/%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>这是一个测试文档，用来测试新建一篇文章。</p><h1 id="正文">正文</h1><p class="note note-warning">Warning：内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h1 id="一级标题">一级标题</h1><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h2 id="二级标题">二级标题</h2><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h3 id="三级标题">三级标题</h3><p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h1 id="表格测试">表格测试：</h1><div data-align="center"><table><thead><tr class="header"><th>1</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td></td><td>2</td><td></td></tr><tr class="even"><td></td><td></td><td>3</td></tr><tr class="odd"><td></td><td>4</td><td></td></tr></tbody></table><p>这是一个测试表格</p></div><h1 id="公式测试">公式测试：</h1><p>独行公式：</p><p><span class="math display">\[\frac{1}{\pi}\]</span> 行内公式：<span class="math inline">\(\frac{1}{2}\)</span></p><h1 id="代码测试">代码测试：</h1><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    hello()<br></code></pre></td></tr></table></figure><h1 id="图片测试">图片测试</h1><div align="center"><img src="/img/default.png" width="50%" height="50%"/> <br/>图1 这是一个测试图片<div>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
