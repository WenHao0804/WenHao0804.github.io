<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Sentence Similarity——String Based Methods</title>
    <link href="/2022/03/02/Levenshtein-edit-distance/"/>
    <url>/2022/03/02/Levenshtein-edit-distance/</url>
    
    <content type="html"><![CDATA[<h1 id="opening-question">Opening question</h1><p>我们来考虑这样一个问题：给定两个句子，判断这两个句子之间的相似度。直观来看，如果句子1和句子2之间只有几个字不同，其余字都一模一样，那这两个句子必然极为相似。换言之，如果句子1可以很容易地被修改成句子2，则说明这两个句子相似性很大。</p><blockquote><p>举例说明两个句子极为相似的情况：</p><p>s1 = "我是一只小小小小鸟，想要飞呀飞却飞也飞不高"</p><p>s2 = "我是一条小小小小狗，想要睡呀睡却睡也睡不够"</p></blockquote><p>这个思考问题中涉及到一个核心的问题：什么是相似度。直观来看，两个句子之间的相似度和将它们修改成对方的难易度有关。如果我们可以定量评价将句子1修改成句子2的“成本”，那不是很容易能判断句子之间的相似度了吗？这个“成本”有着规范的名字，也就是编辑距离（Edit Distance）。编辑距离一般使用在对句子的快速模糊匹配上，可以在语法层面上判断句子之间的相似度。语义、语用上的相似度判断，可以利用深度学习计算句子的表征向量并通过计算向量之间的距离（Cosine Distance, etc.）来判断这更高级的相似度。</p><h1 id="hamming距离">Hamming距离</h1><p>我们并不是最先思考编辑距离的人，早在1950年，一位如今大名鼎鼎的科学家汉明（Hamming）在对二元信道检错及纠错码的<a href="https://ieeexplore.ieee.org/ielx7/6731005/6772728/06772729.pdf?tag=1">研究</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Hamming R W . Error detecting and error correcting codes[J]. Bell Labs Technical Journal, 1950, 29(2):147-160.">[1]</span></a></sup>中提出了一种判断<span class="math inline">\(\{0, 1\}^n\)</span>空间内两个坐标距离的方法。这个空间内共有<span class="math inline">\(2^n\)</span>个点，任意一个维度中的坐标只能取0或1。对于此空间内的一个点，如果某个维度下的坐标出了错则该维度下的坐标会从0反转为1或从1反转为0。汉明基于此定义两个点<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>之间的距离<span class="math inline">\(D(x, y)\)</span>为n个维度中<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>坐标不同的数量，这也就是汉明距离。汉明距离有如下特点： <span class="math display">\[\begin{align}D(x,y) = 0 &amp;&amp; if\ and\ only\ if\ x == y \\[5pt]D(x, y) = D(y, x) &gt; 0 &amp;&amp; if\ x \ne y \\[5pt]D(x, y) + D(y, z) \ge D(x, z) &amp;&amp;triangle\ inequality\end{align}\]</span></p><p>我们来举例计算汉明距离：比如<span class="math inline">\(x=[0, 0, 0,1]\)</span>，<span class="math inline">\(y=[0, 0, 1, 0]\)</span>，<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>第3和第4个维度不同，那么它们之间的汉明距离就是2。</p><p>换一种视角，如果我们将<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>当作两个句子，我们就可以利用汉明距离去计算两个句子相互修改的难易“成本”，也就是编辑距离。但这种计算方法有其固有缺点：只能应对两个句子长度相同的情况。如果两个句子长度不同，那我们就无法利用汉明距离计算两个句子间的编辑距离了。</p><h1 id="levenshtein距离">Levenshtein距离</h1><p>那么如何计算两个长度不同的句子之间的编辑距离呢？基于汉明的工作，俄国科学家Levenshtein于1965年在其<a href="https://nymity.ch/sybilhunting/pdf/Levenshtein1966a.pdf">文章</a><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Levenshtein V I . Binary codes capable of correcting deletions, insertions and reversals[J]. Doklady Akademii Nauk SSSR, 1965, 163.">[2]</span></a></sup>《可纠正删除、插入、反转的二进制纠错码》中提出了一种新的判断两个点<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>距离<span class="math inline">\(D(x,y)\)</span>的方法。这种计算方法的物理意义是每次修改一个坐标将<span class="math inline">\(x\)</span>修改为<span class="math inline">\(y\)</span>的最次少数，支持的修改方式有增、删、改。Levenshtein提出的评价指标如今成为了有名的Levenshtein距离，已经被广泛应用在生物信息学（Bioinformatics）、自然语言处理<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Aziz R , Anwar M W , Jamal M H , et al. A hybrid model for spelling error detection and correction for Urdu language[J]. 2021.">[4]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Mei J , Islam A , Moh&#39; D A , et al. Statistical learning for OCR error correction[J]. Information Processing &amp; Management, 2018, 54(6):Pages 874–887.">[5]</span></a></sup>（Nature Language Processing，NLP）等多个研究领域中，用于评价两个序列之间的距离。</p><p>递归性地定义Levenshtein距离如下： <span class="math display">\[D_{x,y}(i, j)=\begin{cases}max(i,j)&amp;&amp;if\ min(i, j) == 0\\[5pt] min\begin{cases}        D_{x,y}(i-1,j)+1\\[5pt]        D_{x,y}(i,j-1)+1 \\[5pt]        D_{x,y}(i-1,j-1)+1_{x_i\ne y_j}\\[5pt]     \end{cases}&amp;&amp;  otherwise\end{cases}\]</span> <span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>表示两个序列（比如字符串），<span class="math inline">\(D_{x,y}(i,j)\)</span>表示<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符之间的Levenshtein距离，其中<span class="math inline">\(i\)</span>、<span class="math inline">\(j\)</span>从1开始计数。如果序列<span class="math inline">\(x\)</span>的长度为0，显然只需要插入<span class="math inline">\(j\)</span>个字符就可以将<span class="math inline">\(x\)</span>变成<span class="math inline">\(y\)</span>，同理对于<span class="math inline">\(y\)</span>的长度为0时也适用。当两个序列长度均不为0时，存在三种情况：</p><ol type="1"><li>删除<span class="math inline">\(x_[i]\)</span>，使<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符相同</li><li>删除<span class="math inline">\(y[j]\)</span>，使<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符相同</li><li><span class="math inline">\(x\)</span>的前<span class="math inline">\(i-1\)</span>个字符经过操作已经和<span class="math inline">\(y\)</span>的前<span class="math inline">\(j-1\)</span>个字符相同时，为使<span class="math inline">\(x\)</span>的前<span class="math inline">\(i\)</span>个字符与<span class="math inline">\(y\)</span>的前<span class="math inline">\(j\)</span>个字符相同：<ul><li>如果<span class="math inline">\(x[i]==y[j]\)</span>，则无需操作；</li><li>否则，将<span class="math inline">\(x[i]\)</span>修改成<span class="math inline">\(y[j]\)</span>或将将<span class="math inline">\(y[i]\)</span>修改成<span class="math inline">\(x[j]\)</span>即可</li></ul></li></ol><p>显然，计算Levenshtein距离要明显比计算汉明距离困难。不过一旦理清算法，用计算机实现轻而易举。</p><h2 id="levenshtein距离的编程实现">Levenshtein距离的编程实现</h2><h3 id="递归实现">递归实现</h3><p>上方我们已经得到了Levenshtein距离的递归定义式，接下来我们只需要将这个递归式放入编程语言中即可。为了提升效率，我们需要对递归结果进行缓存，要不然会产生太多重复计算，一旦句子太长等递归结果出来就要天荒地老了。不过递归加上缓存之后，也就不再是纯粹的递归了。利用python可以较简洁地递归计算Levenshtein距离，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-meta">@functools.lru_cache</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">levenshtein</span>(<span class="hljs-params">sentence1, sentence2, i=<span class="hljs-literal">None</span>, j=<span class="hljs-literal">None</span></span>):<br>    i = i <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(sentence1)<br>    j = j <span class="hljs-keyword">if</span> j <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(sentence2)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> i <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> j:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(i, j)<br>    cost = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> sentence1[i-<span class="hljs-number">1</span>] != sentence2[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<br>        levenshtein(sentence1, sentence2, i - <span class="hljs-number">1</span>, j) + <span class="hljs-number">1</span>,<br>        levenshtein(sentence1, sentence2, i, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>,<br>        levenshtein(sentence1, sentence2, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + cost,<br>    )<br></code></pre></td></tr></table></figure><h3 id="递推实现动态规划">递推实现（动态规划）</h3><p>递归转递推其实就是显式地用数组来表达递归调用栈，并从递归过程的最底层往上递推，这样的方法也就是动态规划（Dynamic Programming，DP）。代码如下，整体上和递归代码差别不大，无非是多了显式递推的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">levenshtein</span>(<span class="hljs-params">sentence1, sentence2</span>):<br>    n1, n2 = <span class="hljs-built_in">len</span>(sentence1), <span class="hljs-built_in">len</span>(sentence2)<br>    dp = [[<span class="hljs-number">0</span>] * (n2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1 + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n1 + <span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n2 + <span class="hljs-number">1</span>):<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n1 + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n2 + <span class="hljs-number">1</span>):<br>            cost = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> sentence1[i - <span class="hljs-number">1</span>] == sentence2[j - <span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(<br>                dp[i-<span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,<br>                dp[i][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,<br>                dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + cost,<br>            )<br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="levenshtein距离的变种">Levenshtein距离的变种</h2><p>如果我们拓展Levenshtein距离允许的编辑操作呢？比如Zhao等人<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="ZHAO Z peng, YIN Z min, WANG Q ping, 等. An improved algorithm of Levenshtein Distance and its application in data processing[J/OL]. Journal of Computer Applications, 2009, 29(2): 424-426. DOI:10.3724/SP.J.1087.2009.00424.">[8]</span></a></sup>提出了一种扩展操作：交换。Zhao等人允许对长度<span class="math inline">\(\ge2\)</span>的词进行交换。当<span class="math inline">\(x[i-k:i+1]==y[j-k:j+1]\)</span>或<span class="math inline">\(x[i-k:i+1]==y[j:j+k+1]\)</span>出现频率较高时，我们可以通过交换这些词来减少编辑距离。比如：<span class="math inline">\(x=\)</span>“老师您好”, <span class="math inline">\(y=\)</span>“你好老师”，传统Levenshtein距离计算结果为4，而使用Zhao等人提出的编辑距离计算则距离为1。可以看出在句子中含有固定词组时，拓展交换词语的操作更能体现句子之间的相似情况，也更能体现交换操作的优势。</p>整体上Zhao等人优化后的编辑距离定义如下： $$ D_{x,y}(i, j)=<span class="math display">\[\begin{cases}max(i,j)&amp;&amp;if\ min(i, j) == 0\\[5pt] min\begin{cases}        D_{x,y}(i-1,j)+1\\[5pt]        D_{x,y}(i,j-1)+1 \\[5pt]        D_{x,y}(i-1,j-1)+1_{x_i\ne y_j}\\[5pt]        D_{x,y}(i-1-k,j-1-k)+1&amp;&amp;if\ x[i-k:i+1]==y[j-k:j+1]\\[5pt]        D_{x,y}(i-1-k,j+k)+1&amp;&amp;if\ x[i-k:i+1]==y[j:j+k+1]\\[5pt]      \end{cases} &amp;&amp;  otherwise\\      \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1 \le k \le min(m, n)\end{cases}\]</span><p>$$</p><h1 id="最长公共子序列longest-common-subsequencelcs">最长公共子序列（Longest Common Subsequence，LCS）</h1><h2 id="lcs问题定义">LCS问题定义</h2><p>Levenshtein距离允许的编辑操作为：删除、插入、替换。这样的编辑操作就是较为常用的编辑定义，因此我们在提到编辑距离时，通常指的就是Levenshtein距离。如果我们限定编辑操作仅指替换，那这样的编辑距离就是我们在上方提到的Hamming距离。</p><p>如果我们限定编辑操作为删除、插入呢？换句话来说：给定句子1和句子2，一次可对任一句子进行删除或插入的操作，最少操作多少步可使得句子1和句子2相同？</p><p>我们先从结果出发。显然，经过操作后，两个句子剩下的部分在原始句子中依然存在，但可能每个字符的下标发生了变化。那么这个问题就可以被转化为，求两个句子的最长公共子序列（Longest Common Subsequence，LCS）问题。</p><p><img src="/img/lcs.png"/></p><p align="center" style="font-size: small;">图1 两个序列的最长公共子序列，如"AGGTAB"和"GXTXAYB"的最长公共子序列是"GTAB"</p><p>LCS问题是一个经典的计算机科学问题，也是如diff、git等具有数据比较功能程序的算法基础。在LCS问题中，子序列不需要在原序列中占用连续的位置。一般性的LCS问题是NP-hard问题。但当序列的长度确定时，LCS问题可以使用动态规划在多项式时间内解决<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="屈, 婉玲. 算法设计与分析. 北京清华大学学研大厦A座: 清华大学出版社. 2011: 67. ISBN 978-7-302-24756-2.">[6]</span></a></sup>。计算出LCS之后，两个句子之间的编辑距离显而易见：</p><p><span class="math display">\[D_{x,y}=l_x + l_y - 2 \times lcs(x,y)\]</span></p><h2 id="两个序列lcs的解法">两个序列LCS的解法</h2><p>我们仍然可以递归性地定义LCS： <span class="math display">\[LCS_{x,y}(i,j)=\begin{cases}0 &amp;&amp; if\ i==0\ or\ j==0 \\[5pt] LCS_{x,y}(i-1,j-1)+1 &amp;&amp; if\ x[i]==x[j]\\[5pt] max(LCS_{x,y}(i-1, j), LCS_{x,y}(i, j-1)) &amp;&amp; otherwise\\\end{cases}\]</span></p><ul><li>显然，只要句子<code>x</code>和<code>y</code>只要有一个长度为0，那它们的LCS就为0。因为只能通过删除较长句子中的符号至为空，或者在空句子中添加符号来使得两个句子相等。</li><li>如果<code>x[i]</code>和<code>y[j]</code>相等，则<code>x[:i]</code>与<code>y[:j]</code>之间的LCS就是<code>x[:i-1]</code>与<code>y[:j-1]</code>之间的LCS+1。</li><li>如果<code>x[i]</code>和<code>y[j]</code>不等，如果想通过LCS问题支持的操作来使<code>x[:i]</code>与<code>y[:j]</code>编辑至相等，则有两种情况：<ol type="1"><li><p>删除<code>x[i]</code></p></li><li><p>删除<code>y[j]</code></p></li></ol>我们应该选择这两种情况中最长的LCS来当作<code>x[:i]</code>与<code>y[:j]</code>的LCS。</li></ul><h3 id="lcs递归解法">LCS递归解法</h3><p>我们可以直接用编程语言来表达上方的递归定义式。同样的，我们给递归式加上缓存，以避免过多重复的计算。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-meta">@lru_cache</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcs</span>(<span class="hljs-params">s1, s2, i=<span class="hljs-literal">None</span>, j=<span class="hljs-literal">None</span></span>):<br>    i = i <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(s1) - <span class="hljs-number">1</span><br>    j = j <span class="hljs-keyword">if</span> j <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">len</span>(s2) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == -<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>        <span class="hljs-keyword">return</span> lcs(s1, s2, i-<span class="hljs-number">1</span>, j-<span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lcs(s1, s2, i-<span class="hljs-number">1</span>, j), lcs(s1, s2, i, j-<span class="hljs-number">1</span>))<br><br></code></pre></td></tr></table></figure><h3 id="lcs递推解法动态规划">LCS递推解法（动态规划）</h3><p>利用python语言的负数索引，我们可以较为优雅地递推实现LCS。如下代码里当<code>i==0</code>，<code>j==0</code>时，会产生负数索引，不过并不影响python语言中对数组的访问，而且便利了<code>s1</code>和<code>s2</code>成员的访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcs</span>(<span class="hljs-params">s1, s2</span>):<br>    n1, n2 = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2)<br>    dp = [[<span class="hljs-number">0</span>] * (n2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1 + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n2):<br>            <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>                dp[i][j] = <span class="hljs-number">1</span> + dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> dp[n1 - <span class="hljs-number">1</span>][n2 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="最长公共子串longest-common-substring">最长公共子串（Longest Common Substring）</h1><p>最长公共子串也可以用来评价两个序列之间的相似性。其定义是寻找两个序列之间最长的连续串（子串），这和LCS问题稍有不同。我们依然可以递归式地定义此问题： <span class="math display">\[D_{x,y}(i, j)=\begin{cases}D_{x,y}(i-1,j-1)+1 &amp;&amp; if\ x[i]==x[j]\\[5pt] 0 &amp;&amp; if\ min(i,j)==0\ or\ x[i]\ne y[j]\\\end{cases}\]</span> 但实际计算过程中就不是上面的式子那么简单。我们要得到的是递归过程中产生的最大值，这样就必需用一个外部变量来记录，这样的实现确实不够优雅。所以给出如下递推程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lcs_</span>(<span class="hljs-params">s1, s2</span>)-&gt;<span class="hljs-built_in">int</span>:<br>    n1, n2 = <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">len</span>(s2)<br>    dp = [[<span class="hljs-number">0</span>] * (n2 + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1 + <span class="hljs-number">1</span>)]<br>    longest = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n1):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n2):<br>            <span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                longest = <span class="hljs-built_in">max</span>(dp[i][j], longest)<br>    <span class="hljs-keyword">return</span> longest<br></code></pre></td></tr></table></figure><p>实际上最长公共子串问题还可以用贪心的方法来做。受到冯<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="冯凯, 王小华, 谌志群. 基于动态规划的汉语句子相似度算法[J]. 计算机工程, 2013, 39(2):5.">[9]</span></a></sup>等人的启发，我们可以用贪心的做法来获得两个序列之初间的最长公共子串。具体做法如下：</p><h1 id="计算句子相似度">计算句子相似度</h1><h2 id="基于编辑距离计算句子相似度">基于编辑距离计算句子相似度</h2><p>文章开头，我们在思考如何判断句子之间的相似度。但大部分时间我们都在思考将两个句子修改至相同所耗费的“成本”，也就是编辑距离。当编辑操作支持的内容不同时，编辑距离的定义和计算方式也不同。</p><p>编辑距离本身就能描述两个序列之间的相似程度。客观上看，编辑距离越小，则序列间的相似度越大。如下公式<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="王智慧. 基于改进Levenshtein距离算法的轮廓匹配技术及实现[D]. 河南大学.">[7]</span></a></sup>定义了基于Levenshtein距离的句子相似度计算方式，其中<span class="math inline">\(ld\)</span>代表Levenshtein距离，如果换成Hammin距离或基于LCS的编辑距离也未尝不可。</p><p><span class="math display">\[sim = 1 - \frac{ld}{max(l_w, l_x)}\]</span></p><h2 id="基于最长公共子串计算句子相似度">基于最长公共子串计算句子相似度</h2><blockquote><blockquote><blockquote><p>【TODO】待更新</p></blockquote></blockquote></blockquote><hr /><h1 id="references">References：</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Hamming R W . Error detecting and error correcting codes[J]. Bell Labs Technical Journal, 1950, 29(2):147-160. <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Levenshtein V I . Binary codes capable of correcting deletions, insertions and reversals[J]. Doklady Akademii Nauk SSSR, 1965, 163. <a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Berger B , Waterman M S , Yu Y W . Levenshtein Distance, Sequence Comparison and Biological Database Search[J]. IEEE Transactions on Information Theory, 2020, PP(99):1-1. <a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Aziz R , Anwar M W , Jamal M H , et al. A hybrid model for spelling error detection and correction for Urdu language[J]. 2021. <a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Mei J , Islam A , Moh' D A , et al. Statistical learning for OCR error correction[J]. Information Processing &amp; Management, 2018, 54(6):Pages 874–887. <a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>屈, 婉玲. 算法设计与分析. 北京清华大学学研大厦A座: 清华大学出版社. 2011: 67. ISBN 978-7-302-24756-2. <a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>王智慧. 基于改进Levenshtein距离算法的轮廓匹配技术及实现[D]. 河南大学. <a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>ZHAO Z peng, YIN Z min, WANG Q ping, 等. An improved algorithm of Levenshtein Distance and its application in data processing[J/OL]. Journal of Computer Applications, 2009, 29(2): 424-426. DOI:10.3724/SP.J.1087.2009.00424. <a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>冯凯, 王小华, 谌志群. 基于动态规划的汉语句子相似度算法[J]. 计算机工程, 2013, 39(2):5. <a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About the blog</title>
    <link href="/2022/03/01/about-blog/"/>
    <url>/2022/03/01/about-blog/</url>
    
    <content type="html"><![CDATA[<p>本博客基于<a href="https://hexo.io">hexo</a>框架搭建，使用主题为<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>。</p><p>hexo的文档参考<a href="https://hexo.io/docs">链接</a>, fluid主题的配置文档参考<a href="https://hexo.fluid-dev.com/docs/guide/">链接</a></p><h3 id="section">2022-03-06</h3><p>初步为博客的文章页面添加了评论功能，评论系统基于<a href="https://valine.js.org/">valine.js</a></p><h3 id="section-1">2022-02-27</h3><p>正式建立此博客</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/27/hello-world/"/>
    <url>/2022/02/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个测试文档</title>
    <link href="/2022/02/27/%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"/>
    <url>/2022/02/27/%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>这是一个测试文档，用来测试新建一篇文章。</p><h1 id="正文">正文</h1><p class="note note-warning">Warning：内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h1 id="一级标题">一级标题</h1><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h2 id="二级标题">二级标题</h2><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h3 id="三级标题">三级标题</h3><p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><p>内容内容内容</p><h1 id="表格测试">表格测试：</h1><div data-align="center"><table><thead><tr class="header"><th>1</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td></td><td>2</td><td></td></tr><tr class="even"><td></td><td></td><td>3</td></tr><tr class="odd"><td></td><td>4</td><td></td></tr></tbody></table><p>这是一个测试表格</p></div><h1 id="公式测试">公式测试：</h1><p>独行公式：</p><p><span class="math display">\[\frac{1}{\pi}\]</span> 行内公式：<span class="math inline">\(\frac{1}{2}\)</span></p><h1 id="代码测试">代码测试：</h1><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    hello()<br></code></pre></td></tr></table></figure><h1 id="图片测试">图片测试</h1><div align="center"><img src="/img/default.png" width="50%" height="50%"/> <br/>图1 这是一个测试图片<div>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
