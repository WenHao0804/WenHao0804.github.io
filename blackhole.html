<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Gargantua Redshifted Stars Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: "Courier New", Courier, monospace;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(255, 165, 0, 0.5);
            z-index: 10;
        }
        h1 { font-size: 18px; margin: 0 0 5px 0; letter-spacing: 3px; font-weight: bold;}
        p { font-size: 12px; margin: 0; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>GARGANTUA</h1>
        <p>Status: Stars Redshifted</p>
        <p>拖动旋转 | 滚轮缩放</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
precision highp float;

uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

varying vec2 vUv;

mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }
float hash(float n) { return fract(sin(n)*43758.5453123); }
float noise(vec3 x){
    vec3 p=floor(x); vec3 f=fract(x);
    f=f*f*(3.0-2.0*f);
    float n=p.x+p.y*57.0+113.0*p.z;
    return mix(mix(mix(hash(n+0.0),hash(n+1.0),f.x),
                   mix(hash(n+57.0),hash(n+58.0),f.x),f.y),
               mix(mix(hash(n+113.0),hash(n+114.0),f.x),
                   mix(hash(n+170.0),hash(n+171.0),f.x),f.y),f.z);
}
float fbm(vec3 p){ float f=0.0,w=0.5; for(int i=0;i<5;i++){f+=w*noise(p); p*=2.0; w*=0.5;} return f; }

#define BH_RADIUS 1.0
#define DISK_INNER 2.2
#define DISK_OUTER 7.0

void main(){
    vec2 uv=(gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y;
    vec3 ro=vec3(0.0,1.5,-10.0);
    vec3 target=vec3(0.0,0.0,0.0);
    float mx=(iMouse.x/iResolution.x)*6.28;
    float my=(iMouse.y/iResolution.y-0.5)*3.0;
    mat2 rx=rot(my); mat2 ry=rot(mx+0.5);
    ro.yz*=rx; ro.xz*=ry;
    vec3 fwd=normalize(target-ro);
    vec3 right=normalize(cross(vec3(0,1,0),fwd));
    vec3 up=cross(fwd,right);
    vec3 rd=normalize(fwd*1.5 + right*uv.x + up*uv.y);
    vec3 pos=ro; vec3 dir=rd; vec3 col=vec3(0.0);
    float accumDensity=0.0; vec3 accumColor=vec3(0.0); float glow=0.0; bool hitEventHorizon=false; float r_min=100.0;

    // ------------------ 黑洞+吸积盘 ------------------
    for(int i=0;i<150;i++){
        float r2=dot(pos,pos); float r=sqrt(r2); r_min=min(r_min,r);
        if(r>BH_RADIUS){ float bend=0.25*BH_RADIUS*BH_RADIUS/(r2*r); dir=normalize(dir-pos*bend*0.5); }
        float stepSize=max(0.03,r*0.06); pos+=dir*stepSize;
        if(r<BH_RADIUS){ hitEventHorizon=true; break; }
        float distToPlane=abs(pos.y); float distToCenter=length(pos.xz);
        if(distToCenter>DISK_INNER*0.8 && distToCenter<DISK_OUTER*1.2){ float glowFalloff=exp(-distToPlane*2.0)*exp(-abs(distToCenter-(DISK_INNER+DISK_OUTER)*0.5)*0.5); glow+=glowFalloff*0.005; }
        if(distToPlane<0.4 && distToCenter>DISK_INNER && distToCenter<DISK_OUTER){
            float angularVelocity=12.0/pow(distToCenter,1.5); float rotOffset=iTime*angularVelocity;
            vec3 noiseP=vec3(pos.x,pos.y*3.0,pos.z); mat2 m=mat2(cos(rotOffset),-sin(rotOffset),sin(rotOffset),cos(rotOffset));
            noiseP.xz=m*noiseP.xz; noiseP.y+=iTime*2.0;
            float density=fbm(noiseP*2.5)*0.7 + fbm(noiseP*5.0)*0.3;
            float fade=smoothstep(DISK_INNER,DISK_INNER+0.8,distToCenter)*(1.0-smoothstep(DISK_OUTER-1.5,DISK_OUTER,distToCenter));
            float vFade=exp(-distToPlane*5.0); float intensity=density*fade*vFade*0.2;
            vec3 diskVel=normalize(vec3(-pos.z,0.0,pos.x));
            float doppler=dot(diskVel,-dir); intensity*=pow(max(0.0,1.0+doppler*0.7),3.0);
            vec3 diskCol=mix(vec3(1.0,0.4,0.1),vec3(0.9,0.9,1.0),1.0/(distToCenter-DISK_INNER+0.5));
            diskCol=mix(vec3(0.5,0.1,0.0),diskCol,smoothstep(-0.2,0.2,doppler));
            accumColor+=diskCol*intensity; accumDensity+=intensity; if(accumDensity>1.0) break;
        }
        if(r>40.0) break;
    }

    // ------------------ 背景星空 + Einstein Ring 动态 ------------------
    vec3 bg=vec3(0.0);
    if(!hitEventHorizon && accumDensity<1.0){
        float lensStrength=smoothstep(5.0,1.2,r_min); lensStrength=pow(lensStrength,1.5);
        vec3 bhDir=normalize(pos);

        // 增加时间旋转
        float angleRot=iTime*0.1; // 控制旋转速度
        mat2 timeRot=rot(angleRot);
        vec3 warpedDir=normalize(dir + bhDir*lensStrength*0.35);
        warpedDir.xz = timeRot*warpedDir.xz;

        float lon=atan(warpedDir.x,warpedDir.z); float lat=asin(clamp(warpedDir.y,-1.0,1.0));
        vec2 grid=vec2(120.0,60.0); vec2 cell=floor(vec2(lon,lat)*grid);
        float seedBase=cell.x+cell.y*57.0; float cellRand=hash(seedBase);
        vec3 stars=vec3(0.0);

        if(cellRand>0.995){
            float rx=hash(seedBase+1.0)-0.5; float ry=hash(seedBase+2.0)-0.5;
            float starLon=(cell.x+0.5+rx)/grid.x*6.2831853-3.1415926;
            float starLat=(cell.y+0.5+ry)/grid.y*3.1415926-1.5707963;
            vec3 starDir=normalize(vec3(sin(starLon)*cos(starLat), sin(starLat), cos(starLon)*cos(starLat)));
            float baseRadius=mix(0.003,0.018,pow(hash(seedBase+3.0),2.0));
            float starRadius=baseRadius*(1.0+lensStrength*80.0);
            vec3 axis=normalize(cross(starDir,bhDir));
            float ang=acos(clamp(dot(warpedDir,starDir),-1.0,1.0));
            float stretchFactor=1.0+lensStrength*5.0;
            ang=pow(ang,0.7)/stretchFactor;
            float profile=exp(-(ang*ang)/(2.0*starRadius*starRadius))*smoothstep(starRadius*2.0,0.0,ang);
            float bright=profile*(0.6+3.0*lensStrength)*(1.0+cellRand*2.0);
            vec3 starTint=mix(vec3(0.8,0.9,1.0),vec3(1.0,0.7,0.5),hash(seedBase+4.0));
            stars+=starTint*bright;
        }

        float neb=fbm(warpedDir*3.0);
        vec3 nebulaCol=mix(vec3(0.0,0.0,0.06),vec3(0.12,0.06,0.18),neb);
        vec3 bgLocal=stars+nebulaCol;

        float redshiftWeight=1.0-smoothstep(1.5,3.0,r_min);
        redshiftWeight=pow(redshiftWeight,2.0);
        vec3 redshiftColor=vec3(0.8,0.15,0.0);
        bg=mix(bgLocal,redshiftColor*length(bgLocal)*1.5,redshiftWeight*0.8);
    }

    // ------------------ 最终合成 ------------------
    col=bg*(1.0-accumDensity);
    col+=accumColor*1.5;
    col+=vec3(1.0,0.6,0.3)*glow*0.8;
    col=col/(col+vec3(1.0));
    col=pow(col,vec3(0.4545));
    col=smoothstep(0.0,1.0,col);
    gl_FragColor=vec4(col,1.0);
}

        `;

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                iMouse: { value: new THREE.Vector2(0, 0) }
            }
        });

        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(mesh);

        document.addEventListener('mousemove', (e) => {
            material.uniforms.iMouse.value.x = e.clientX;
            material.uniforms.iMouse.value.y = e.clientY;
        });

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.iTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>

